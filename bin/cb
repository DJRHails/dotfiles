#!/usr/bin/env bash

# credit: https://gist.github.com/RichardBronosky/56d8f614fab2bacdd8b048fb58d0c0c7
# credit: https://github.com/javier-lopez/learn/master/sh/tools/cb

##? Unifies the copy and paste commands into one 
##? intelligent chainable command.
##?
##? USAGE:
##?     cb [FLAG/OPTIONS] <clipboard>...
##?
##? FLAGS:
##?     -a, --append
##?         append to the given clipboard, do not overwrite.
##?     -i, --ignore-interrupts  
##?         ignore interrupt signals
##?     -t, --target
##?         use given target instead of the default ones
##?     -v, --version
##?         display version
##?     -h, --help
##?         show this help
##?
##? ARGS:
##?     <clipboard>  the file to extract
##?
##? EXAMPLES:
##?     `date | cb`       copy current data to clipboard 
##?     `cb`              paste current clipboard to stdout
##?     `cb | tee d.log`  paste current clipboard to d.log and stdout.
##?     `cb -a`           append current clipboard to the clipboard
##?     `cb -t html`      output clipboard as html, not text

VERSION="2023.01"

cb::basename() {
    [ -z "${1}" ] && return 1 || _basename__name="${1%%/}"
    [ -z "${2}" ] || _basename__suffix="${2}"
    case "${_basename__name}" in
        /*|*/*) _basename__name="$(expr "${_basename__name}" : '.*/\([^/]*\)')" ;;
    esac

    if [ -n "${_basename__suffix}" ] && [ "${#_basename__name}" -gt "${#2}" ]; then
        if [ X"$(printf "%s\\n" "${_basename__name}" | cut -c"$((${#_basename__name} - ${#_basename__suffix} + 1))"-"${#_basename__name}")" \
           = X"$(printf "%s\\n" "${_basename__suffix}")" ]; then
            _basename__name="$(printf "%s\\n" "${_basename__name}" | cut -c1-"$((${#_basename__name} - ${#_basename__suffix}))")"
        fi
    fi

    printf "%s\\n" "${_basename__name}"
}

cb::die() {
    [ -z "${1}" ] || printf "%s\\n" "${*}" >&2
    doc::help_msg "$0" >&2;
}

cb::show_version() {
    printf "%s\\n" "${PROGNAME} ${VERSION}"
}

cb::copy() {
    if command -v "xclip" >/dev/null 2>/dev/null; then
        #dumping xclip's stdout to the bitbucket works around xclip's
        #failure to properly daemonize: https://sourceforge.net/p/xclip/patches/9/
        if [ -n "${append}" ]; then
            (cb::paste 2>/dev/null; cat) | xclip -selection clipboard -i >/dev/null 2>&1
        else
            cat | xclip -selection clipboard -i >/dev/null 2>&1
        fi
    elif command -v "xsel" >/dev/null 2>/dev/null; then
        if [ -n "${append}" ]; then
            (cb::paste 2>/dev/null; cat) | xsel --clipboard
        else
            cat | xsel --clipboard
        fi
    elif command -v "pbcopy" >/dev/null 2>/dev/null; then
        if [ -n "${append}" ]; then
            (cb::paste 2>/dev/null; cat) | pbcopy
        else
            cat | pbcopy
        fi
    elif [ -e /dev/clipboard ]; then
        if [ -n "${append}" ]; then
            (cat /dev/clipboard 2>/dev/null; cat) > /dev/clipboard
        else
            cat > /dev/clipboard
        fi
    else
        cb::die "${PROGNAME}: unrecognized clipboard system"
    fi
}

cb::target() {
    # Check if target is not set
    if [ -z "${target}" ]; then
        # Do nothing
        echo "TEXT"
    elif command -v "xclip" >/dev/null 2>/dev/null; then
        xclip -selection clipboard -out -target TARGETS | grep -i "${target:-text}" | head -n 1
    else
        cb::die "${PROGNAME}: clipboard target not supported"
    fi

}

cb::paste() {
    if command -v "xclip" >/dev/null 2>/dev/null; then
        xclip -selection clipboard -out -target "$(cb::target)"
    elif command -v "xsel" >/dev/null 2>/dev/null; then
        xsel --clipboard
    elif command -v "pbpaste" >/dev/null 2>/dev/null; then
        if [ -z "${target}" ]; then
            pbpaste
        elif [ "${target}" = "html" ]; then
            pbpaste.swift
        fi
    elif [ -e /dev/clipboard ]; then
        cat /dev/clipboard
    else
        cb::die "${PROGNAME}: unrecognized clipboard system"
    fi
}

cb::stdin_is_pipe(){
  [[ -p /dev/stdin ]]
}

cb::stdin_is_tty() {
  [[ -t 0 ]]
}

cb::stdout_is_tty() {
  [[ -t 1 ]]
}

cb::stdin_is_pipe_like(){
    cb::stdin_is_pipe || ! cb::stdin_is_tty
}

cb::main() {
  PROGNAME="$(cb::basename "${0}")"

  for arg in "${@}"; do #parse options
      case "${arg}" in
          -v|--version) cb::show_version; return ;;
          -a|--append) append="1"; shift ;;
          -t|--target) target="${2}"; shift 2 ;;
          -i|--ignore-interrupts) ignore_interrumpts="1"; shift ;;
          -*) cb::die "${PROGNAME}" "${PROGNAME}: unrecognized option '${arg}'" ;;
      esac
  done

  if cb::stdin_is_pipe_like; then
      cb::copy
      cb::paste
  else
      cb::paste
  fi
}

. "$DOTFILES/scripts/core/main.sh"

doc::maybe_help "$@"
[[ $? == 1 ]] && exit

cb::main "$@"